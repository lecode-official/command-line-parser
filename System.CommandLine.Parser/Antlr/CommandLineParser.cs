
#region Using Directives

using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.CodeDom.Compiler;

#endregion

namespace System.CommandLine.Parser.Antlr
{
    /// <summary>
    /// Represents the parser, which applies the grammar rules to the token stream generated by the lexer and generates an abstract syntax tree from it.
    /// </summary>
    [GeneratedCode("ANTLR", "4.5")]
    [CLSCompliant(false)]
    internal partial class CommandLineParser : Antlr4.Runtime.Parser
    {
        #region Constructors

        /// <summary>
        /// Initializes a new <see cref="CommandLineParser"/> instance.
        /// </summary>
        /// <param name="input">The token stream, which is the input to the parser and was generated by the lexer.</param>
        public CommandLineParser(ITokenStream input)
            : base(input)
        {
            this.Interpreter = new ParserATNSimulator(this, CommandLineParser._ATN);
        }

        #endregion

        #region Private Static Fields

        /// <summary>
        /// Contains the names of the literals of the command line lexer.
        /// </summary>
        private static readonly string[] _LiteralNames = { null, "'['", "','", "']'", null, null, null, null, "'true'", "'false'" };

        /// <summary>
        /// Contains the symbolic names of the lexer rules as specified in the original grammar of the lexer.
        /// </summary>
        private static readonly string[] _SymbolicNames = { null, null, null, null, "UnixStyleFlaggedIdentifiers", "WindowsStyleIdentifier", "UnixStyleIdentifier", "AssignmentOperator", "True", "False", "Number", "Digit", "String", "QuotedString", "WhiteSpaces" };

        #endregion

        #region Public Static Fields

        /// <summary>
        /// Contains the names of all the rules of the parser grammar.
        /// </summary>
        public static readonly string[] ruleNames = { "commandLine", "defaultParameter", "parameter", "value"  };

        /// <summary>
        /// Contains the default vocabulary of the parser.
        /// </summary>
        public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

        /// <summary>
        /// Contains the serialized automaton used for parsing the input. This is derived from the parser grammar.
        /// </summary>
        public static readonly string _serializedATN =
            "\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\x10\x42\x4\x2\t" +
            "\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x3\x2\a\x2\f\n\x2\f\x2\xE\x2\xF\v" +
            "\x2\x3\x2\a\x2\x12\n\x2\f\x2\xE\x2\x15\v\x2\x3\x3\x3\x3\x5\x3\x19\n\x3" +
            "\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3" +
            "\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x5\x4-\n\x4\x3\x5\x3\x5\x3\x5" +
            "\x3\x5\x3\x5\x3\x5\x3\x5\a\x5\x36\n\x5\f\x5\xE\x5\x39\v\x5\x5\x5;\n\x5" +
            "\x3\x5\x3\x5\x3\x5\x5\x5@\n\x5\x3\x5\x2\x2\x6\x2\x4\x6\b\x2\x2O\x2\r\x3" +
            "\x2\x2\x2\x4\x18\x3\x2\x2\x2\x6,\x3\x2\x2\x2\b?\x3\x2\x2\x2\n\f\x5\x4" +
            "\x3\x2\v\n\x3\x2\x2\x2\f\xF\x3\x2\x2\x2\r\v\x3\x2\x2\x2\r\xE\x3\x2\x2" +
            "\x2\xE\x13\x3\x2\x2\x2\xF\r\x3\x2\x2\x2\x10\x12\x5\x6\x4\x2\x11\x10\x3" +
            "\x2\x2\x2\x12\x15\x3\x2\x2\x2\x13\x11\x3\x2\x2\x2\x13\x14\x3\x2\x2\x2" +
            "\x14\x3\x3\x2\x2\x2\x15\x13\x3\x2\x2\x2\x16\x19\a\xE\x2\x2\x17\x19\a\xF" +
            "\x2\x2\x18\x16\x3\x2\x2\x2\x18\x17\x3\x2\x2\x2\x19\x5\x3\x2\x2\x2\x1A" +
            "-\a\a\x2\x2\x1B\x1C\a\a\x2\x2\x1C\x1D\a\t\x2\x2\x1D-\x5\b\x5\x2\x1E\x1F" +
            "\a\a\x2\x2\x1F-\x5\b\x5\x2 !\a\b\x2\x2!\"\a\t\x2\x2\"-\x5\b\x5\x2#$\a" +
            "\b\x2\x2$-\x5\b\x5\x2%-\a\b\x2\x2&\'\a\x6\x2\x2\'(\a\t\x2\x2(-\x5\b\x5" +
            "\x2)*\a\x6\x2\x2*-\x5\b\x5\x2+-\a\x6\x2\x2,\x1A\x3\x2\x2\x2,\x1B\x3\x2" +
            "\x2\x2,\x1E\x3\x2\x2\x2, \x3\x2\x2\x2,#\x3\x2\x2\x2,%\x3\x2\x2\x2,&\x3" +
            "\x2\x2\x2,)\x3\x2\x2\x2,+\x3\x2\x2\x2-\a\x3\x2\x2\x2.@\a\xE\x2\x2/@\a" +
            "\xF\x2\x2\x30@\a\f\x2\x2\x31:\a\x3\x2\x2\x32\x37\x5\b\x5\x2\x33\x34\a" +
            "\x4\x2\x2\x34\x36\x5\b\x5\x2\x35\x33\x3\x2\x2\x2\x36\x39\x3\x2\x2\x2\x37" +
            "\x35\x3\x2\x2\x2\x37\x38\x3\x2\x2\x2\x38;\x3\x2\x2\x2\x39\x37\x3\x2\x2" +
            "\x2:\x32\x3\x2\x2\x2:;\x3\x2\x2\x2;<\x3\x2\x2\x2<@\a\x5\x2\x2=@\a\n\x2" +
            "\x2>@\a\v\x2\x2?.\x3\x2\x2\x2?/\x3\x2\x2\x2?\x30\x3\x2\x2\x2?\x31\x3\x2" +
            "\x2\x2?=\x3\x2\x2\x2?>\x3\x2\x2\x2@\t\x3\x2\x2\x2\t\r\x13\x18,\x37:?";

        /// <summary>
        /// Contains the automaton that is used for parsing the input.
        /// </summary>
        public static readonly ATN _ATN = new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());

        #endregion

        #region Public Constants

        /// <summary>
        /// Contains the ID of the first lexer rule, which is an implicit one.
        /// </summary>
        public const int T__0 = 1;

        /// <summary>
        /// Contains the ID of the second lexer rule, which is an implicit one.
        /// </summary>
        public const int T__1 = 2;

        /// <summary>
        /// Contains the ID of the third lexer rule, which is an implicit one.
        /// </summary>
        public const int T__2 = 3;

        /// <summary>
        /// Contains the ID of the UNIX style flagged identifiers lexer rule.
        /// </summary>
        public const int UnixStyleFlaggedIdentifiers = 4;

        /// <summary>
        /// Contains the ID of the Windows style identifier lexer rule.
        /// </summary>
        public const int WindowsStyleIdentifier = 5;

        /// <summary>
        /// Contains the ID of the UNIX style identifier lexer rule.
        /// </summary>
        public const int UnixStyleIdentifier = 6;

        /// <summary>
        /// Contains the ID of the assignment operator lexer rule.
        /// </summary>
        public const int AssignmentOperator = 7;

        /// <summary>
        /// Contains the ID of the lexer rule for the boolean value true.
        /// </summary>
        public const int True = 8;

        /// <summary>
        /// Contains the ID of the lexer rule for the boolean value false.
        /// </summary>
        public const int False = 9;

        /// <summary>
        /// Contains the ID of the lexer rule for numbers.
        /// </summary>
        public const int Number = 10;

        /// <summary>
        /// Contains the ID of the lexer rule for digits.
        /// </summary>
        public const int Digit = 11;

        /// <summary>
        /// Contains the ID of the lexer rule for strings.
        /// </summary>
        public const int String = 12;

        /// <summary>
        /// Contains the ID of the lexer rule for quoted strings.
        /// </summary>
        public const int QuotedString = 13;

        /// <summary>
        /// Contains the ID of the lexer rule for white spaces.
        /// </summary>
        public const int WhiteSpaces = 14;

        /// <summary>
        /// Contains the ID of the command line parser rule, which is the starting rule.
        /// </summary>
        public const int RULE_commandLine = 0;

        /// <summary>
        /// Contains the ID of the default parameter parser rule.
        /// </summary>
        public const int RULE_defaultParameter = 1;

        /// <summary>
        /// Contains the ID of the parameter parser rule.
        /// </summary>
        public const int RULE_parameter = 2;

        /// <summary>
        /// Contains the ID of the value parser rule.
        /// </summary>
        public const int RULE_value = 3;

        #endregion

        #region Public Properties

        /// <summary>
        /// Gets the vocabulary of the parser.
        /// </summary>
        [NotNull]
        public override IVocabulary Vocabulary
        {
            get
            {
                return CommandLineParser.DefaultVocabulary;
            }
        }

        /// <summary>
        /// Gets the name of the grammar file from which the parser was generated.
        /// </summary>
        public override string GrammarFileName
        {
            get
            {
                return "CommandLine.g4";
            }
        }

        /// <summary>
        /// Gets the names of the rules of the parser.
        /// </summary>
        public override string[] RuleNames
        {
            get
            {
                return CommandLineParser.ruleNames;
            }
        }

        /// <summary>
        /// Gets the serialized automaton, which is used by the parser.
        /// </summary>
        public override string SerializedAtn
        {
            get
            {
                return CommandLineParser._serializedATN;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Invokes the parsing of the command line parser rule, which is the starting rule.
        /// </summary>
        /// <returns>Returns the parse tree that was generated.</returns>
        [RuleVersion(0)]
        public CommandLineContext commandLine()
        {
            CommandLineContext _localctx = new CommandLineContext(Context, State);
            EnterRule(_localctx, 0, RULE_commandLine);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 11;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.La(1);
                    while (_la == String || _la == QuotedString)
                    {
                        {
                            {
                                State = 8; defaultParameter();
                            }
                        }
                        State = 13;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.La(1);
                    }
                    State = 17;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.La(1);
                    while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << UnixStyleFlaggedIdentifiers) | (1L << WindowsStyleIdentifier) | (1L << UnixStyleIdentifier))) != 0))
                    {
                        {
                            {
                                State = 14; parameter();
                            }
                        }
                        State = 19;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.La(1);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        /// <summary>
        /// Invokes the parsing of the value parser rule.
        /// </summary>
        /// <returns>Returns the parse tree that was generated.</returns>
        [RuleVersion(0)]
        public ValueContext value()
        {
            ValueContext _localctx = new ValueContext(Context, State);
            EnterRule(_localctx, 6, RULE_value);
            int _la;
            try
            {
                State = 61;
                switch (TokenStream.La(1))
                {
                    case String:
                        _localctx = new StringContext(_localctx);
                        EnterOuterAlt(_localctx, 1);
                        {
                            State = 44; Match(String);
                        }
                        break;
                    case QuotedString:
                        _localctx = new StringContext(_localctx);
                        EnterOuterAlt(_localctx, 2);
                        {
                            State = 45; Match(QuotedString);
                        }
                        break;
                    case Number:
                        _localctx = new NumberContext(_localctx);
                        EnterOuterAlt(_localctx, 3);
                        {
                            State = 46; Match(Number);
                        }
                        break;
                    case T__0:
                        _localctx = new ArrayContext(_localctx);
                        EnterOuterAlt(_localctx, 4);
                        {
                            State = 47; Match(T__0);
                            State = 56;
                            _la = TokenStream.La(1);
                            if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__0) | (1L << True) | (1L << False) | (1L << Number) | (1L << String) | (1L << QuotedString))) != 0))
                            {
                                {
                                    State = 48; value();
                                    State = 53;
                                    ErrorHandler.Sync(this);
                                    _la = TokenStream.La(1);
                                    while (_la == T__1)
                                    {
                                        {
                                            {
                                                State = 49; Match(T__1);
                                                State = 50; value();
                                            }
                                        }
                                        State = 55;
                                        ErrorHandler.Sync(this);
                                        _la = TokenStream.La(1);
                                    }
                                }
                            }

                            State = 58; Match(T__2);
                        }
                        break;
                    case True:
                        _localctx = new BooleanContext(_localctx);
                        EnterOuterAlt(_localctx, 5);
                        {
                            State = 59; Match(True);
                        }
                        break;
                    case False:
                        _localctx = new BooleanContext(_localctx);
                        EnterOuterAlt(_localctx, 6);
                        {
                            State = 60; Match(False);
                        }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }
        
        #endregion

        #region Nested Types

        public partial class CommandLineContext : ParserRuleContext {
            public DefaultParameterContext[] defaultParameter() {
                return GetRuleContexts<DefaultParameterContext>();
            }
            public DefaultParameterContext defaultParameter(int i) {
                return GetRuleContext<DefaultParameterContext>(i);
            }
            public ParameterContext[] parameter() {
                return GetRuleContexts<ParameterContext>();
            }
            public ParameterContext parameter(int i) {
                return GetRuleContext<ParameterContext>(i);
            }
            public CommandLineContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_commandLine; } }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
                ICommandLineVisitor<TResult> typedVisitor = visitor as ICommandLineVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitCommandLine(this);
                else return visitor.VisitChildren(this);
            }
        }

        public partial class DefaultParameterContext : ParserRuleContext
        {
            public DefaultParameterContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_defaultParameter; } }

            public DefaultParameterContext() { }
            public virtual void CopyFrom(DefaultParameterContext context)
            {
                base.CopyFrom(context);
            }
        }

        public partial class DefaultParameterStringContext : DefaultParameterContext
        {
            public ITerminalNode String() { return GetToken(CommandLineParser.String, 0); }
            public ITerminalNode QuotedString() { return GetToken(CommandLineParser.QuotedString, 0); }
            public DefaultParameterStringContext(DefaultParameterContext context) { CopyFrom(context); }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICommandLineVisitor<TResult> typedVisitor = visitor as ICommandLineVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitDefaultParameterString(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public DefaultParameterContext defaultParameter()
        {
            DefaultParameterContext _localctx = new DefaultParameterContext(Context, State);
            EnterRule(_localctx, 2, RULE_defaultParameter);
            try
            {
                State = 22;
                switch (TokenStream.La(1))
                {
                    case String:
                        _localctx = new DefaultParameterStringContext(_localctx);
                        EnterOuterAlt(_localctx, 1);
                        {
                            State = 20; Match(String);
                        }
                        break;
                    case QuotedString:
                        _localctx = new DefaultParameterStringContext(_localctx);
                        EnterOuterAlt(_localctx, 2);
                        {
                            State = 21; Match(QuotedString);
                        }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class ParameterContext : ParserRuleContext
        {
            public ParameterContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_parameter; } }

            public ParameterContext() { }
            public virtual void CopyFrom(ParameterContext context)
            {
                base.CopyFrom(context);
            }
        }

        public partial class UnixStyleSwitchContext : ParameterContext
        {
            public ITerminalNode UnixStyleIdentifier() { return GetToken(CommandLineParser.UnixStyleIdentifier, 0); }
            public UnixStyleSwitchContext(ParameterContext context) { CopyFrom(context); }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICommandLineVisitor<TResult> typedVisitor = visitor as ICommandLineVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitUnixStyleSwitch(this);
                else return visitor.VisitChildren(this);
            }
        }

        public partial class UnixStyleAliasParameterContext : ParameterContext
        {
            public ITerminalNode UnixStyleFlaggedIdentifiers() { return GetToken(CommandLineParser.UnixStyleFlaggedIdentifiers, 0); }
            public ITerminalNode AssignmentOperator() { return GetToken(CommandLineParser.AssignmentOperator, 0); }
            public ValueContext value()
            {
                return GetRuleContext<ValueContext>(0);
            }
            public UnixStyleAliasParameterContext(ParameterContext context) { CopyFrom(context); }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICommandLineVisitor<TResult> typedVisitor = visitor as ICommandLineVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitUnixStyleAliasParameter(this);
                else return visitor.VisitChildren(this);
            }
        }

        public partial class WindowsStyleParameterContext : ParameterContext
        {
            public ITerminalNode WindowsStyleIdentifier() { return GetToken(CommandLineParser.WindowsStyleIdentifier, 0); }
            public ITerminalNode AssignmentOperator() { return GetToken(CommandLineParser.AssignmentOperator, 0); }
            public ValueContext value()
            {
                return GetRuleContext<ValueContext>(0);
            }
            public WindowsStyleParameterContext(ParameterContext context) { CopyFrom(context); }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICommandLineVisitor<TResult> typedVisitor = visitor as ICommandLineVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitWindowsStyleParameter(this);
                else return visitor.VisitChildren(this);
            }
        }

        public partial class UnixStyleParameterContext : ParameterContext
        {
            public ITerminalNode UnixStyleIdentifier() { return GetToken(CommandLineParser.UnixStyleIdentifier, 0); }
            public ITerminalNode AssignmentOperator() { return GetToken(CommandLineParser.AssignmentOperator, 0); }
            public ValueContext value()
            {
                return GetRuleContext<ValueContext>(0);
            }
            public UnixStyleParameterContext(ParameterContext context) { CopyFrom(context); }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICommandLineVisitor<TResult> typedVisitor = visitor as ICommandLineVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitUnixStyleParameter(this);
                else return visitor.VisitChildren(this);
            }
        }

        public partial class UnixStyleFlaggedSwitchContext : ParameterContext
        {
            public ITerminalNode UnixStyleFlaggedIdentifiers() { return GetToken(CommandLineParser.UnixStyleFlaggedIdentifiers, 0); }
            public UnixStyleFlaggedSwitchContext(ParameterContext context) { CopyFrom(context); }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICommandLineVisitor<TResult> typedVisitor = visitor as ICommandLineVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitUnixStyleFlaggedSwitch(this);
                else return visitor.VisitChildren(this);
            }
        }

        public partial class WindowsStyleSwitchContext : ParameterContext
        {
            public ITerminalNode WindowsStyleIdentifier() { return GetToken(CommandLineParser.WindowsStyleIdentifier, 0); }
            public WindowsStyleSwitchContext(ParameterContext context) { CopyFrom(context); }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICommandLineVisitor<TResult> typedVisitor = visitor as ICommandLineVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitWindowsStyleSwitch(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public ParameterContext parameter()
        {
            ParameterContext _localctx = new ParameterContext(Context, State);
            EnterRule(_localctx, 4, RULE_parameter);
            try
            {
                State = 42;
                switch (Interpreter.AdaptivePredict(TokenStream, 3, Context))
                {
                    case 1:
                        _localctx = new WindowsStyleSwitchContext(_localctx);
                        EnterOuterAlt(_localctx, 1);
                        {
                            State = 24; Match(WindowsStyleIdentifier);
                        }
                        break;
                    case 2:
                        _localctx = new WindowsStyleParameterContext(_localctx);
                        EnterOuterAlt(_localctx, 2);
                        {
                            State = 25; Match(WindowsStyleIdentifier);
                            State = 26; Match(AssignmentOperator);
                            State = 27; value();
                        }
                        break;
                    case 3:
                        _localctx = new WindowsStyleParameterContext(_localctx);
                        EnterOuterAlt(_localctx, 3);
                        {
                            State = 28; Match(WindowsStyleIdentifier);
                            State = 29; value();
                        }
                        break;
                    case 4:
                        _localctx = new UnixStyleParameterContext(_localctx);
                        EnterOuterAlt(_localctx, 4);
                        {
                            State = 30; Match(UnixStyleIdentifier);
                            State = 31; Match(AssignmentOperator);
                            State = 32; value();
                        }
                        break;
                    case 5:
                        _localctx = new UnixStyleParameterContext(_localctx);
                        EnterOuterAlt(_localctx, 5);
                        {
                            State = 33; Match(UnixStyleIdentifier);
                            State = 34; value();
                        }
                        break;
                    case 6:
                        _localctx = new UnixStyleSwitchContext(_localctx);
                        EnterOuterAlt(_localctx, 6);
                        {
                            State = 35; Match(UnixStyleIdentifier);
                        }
                        break;
                    case 7:
                        _localctx = new UnixStyleAliasParameterContext(_localctx);
                        EnterOuterAlt(_localctx, 7);
                        {
                            State = 36; Match(UnixStyleFlaggedIdentifiers);
                            State = 37; Match(AssignmentOperator);
                            State = 38; value();
                        }
                        break;
                    case 8:
                        _localctx = new UnixStyleAliasParameterContext(_localctx);
                        EnterOuterAlt(_localctx, 8);
                        {
                            State = 39; Match(UnixStyleFlaggedIdentifiers);
                            State = 40; value();
                        }
                        break;
                    case 9:
                        _localctx = new UnixStyleFlaggedSwitchContext(_localctx);
                        EnterOuterAlt(_localctx, 9);
                        {
                            State = 41; Match(UnixStyleFlaggedIdentifiers);
                        }
                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class ValueContext : ParserRuleContext
        {
            public ValueContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_value; } }

            public ValueContext() { }
            public virtual void CopyFrom(ValueContext context)
            {
                base.CopyFrom(context);
            }
        }

        public partial class NumberContext : ValueContext
        {
            public ITerminalNode Number() { return GetToken(CommandLineParser.Number, 0); }
            public NumberContext(ValueContext context) { CopyFrom(context); }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICommandLineVisitor<TResult> typedVisitor = visitor as ICommandLineVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitNumber(this);
                else return visitor.VisitChildren(this);
            }
        }

        public partial class StringContext : ValueContext
        {
            public ITerminalNode String() { return GetToken(CommandLineParser.String, 0); }
            public ITerminalNode QuotedString() { return GetToken(CommandLineParser.QuotedString, 0); }
            public StringContext(ValueContext context) { CopyFrom(context); }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICommandLineVisitor<TResult> typedVisitor = visitor as ICommandLineVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitString(this);
                else return visitor.VisitChildren(this);
            }
        }

        public partial class ArrayContext : ValueContext
        {
            public ValueContext[] value()
            {
                return GetRuleContexts<ValueContext>();
            }
            public ValueContext value(int i)
            {
                return GetRuleContext<ValueContext>(i);
            }
            public ArrayContext(ValueContext context) { CopyFrom(context); }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICommandLineVisitor<TResult> typedVisitor = visitor as ICommandLineVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitArray(this);
                else return visitor.VisitChildren(this);
            }
        }

        public partial class BooleanContext : ValueContext
        {
            public ITerminalNode True() { return GetToken(CommandLineParser.True, 0); }
            public ITerminalNode False() { return GetToken(CommandLineParser.False, 0); }
            public BooleanContext(ValueContext context) { CopyFrom(context); }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICommandLineVisitor<TResult> typedVisitor = visitor as ICommandLineVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitBoolean(this);
                else return visitor.VisitChildren(this);
            }
        }

        #endregion
    }
}